; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s --mtriple=wasm32 -mattr=+reference-types | FileCheck %s

!0 = !{!"externref"}
!wasm.type_info = !{!0}

%externref = type ptr addrspace(257)

declare void @externref_user(%externref %ref)

define %externref @local_copied_from_arg(%externref %x, %externref %y, i1 zeroext %bool) {
; CHECK-LABEL: local_copied_from_arg:
; CHECK:         .functype local_copied_from_arg (externref, externref, i32) -> (externref)
; CHECK-NEXT:    .local externref
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get 1
; CHECK-NEXT:    local.set 3
; CHECK-NEXT:    block
; CHECK-NEXT:    local.get 2
; CHECK-NEXT:    br_if 0 # 0: down to label0
; CHECK-NEXT:  # %bb.1: # %if.then.i
; CHECK-NEXT:    local.get 0
; CHECK-NEXT:    local.set 3
; CHECK-NEXT:  .LBB0_2: # %if.end.i
; CHECK-NEXT:    end_block # label0:
; CHECK-NEXT:    local.get 1
; CHECK-NEXT:    call externref_user
; CHECK-NEXT:    local.get 3
; CHECK-NEXT:    # fallthrough-return
entry:
  br i1 %bool, label %if.end.i, label %if.then.i

if.then.i:
  br label %if.end.i

if.end.i:
  %s = phi %externref [ %y, %entry ], [ %x, %if.then.i ]
  ; Add a dummy call to prevent the argument locals from being reused, forcing
  ; the allocation of an additional local.
  call void @externref_user(%externref %y)
  ret %externref %s
}

@g1 = external addrspace(1) global %externref
@g2 = external addrspace(1) global %externref

define %externref @local_copied_from_global(i1 zeroext %bool) {
; CHECK-LABEL: local_copied_from_global:
; CHECK:         .functype local_copied_from_global (i32) -> (externref)
; CHECK-NEXT:    .local externref, externref
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    global.get g2
; CHECK-NEXT:    local.set 1
; CHECK-NEXT:    block
; CHECK-NEXT:    local.get 0
; CHECK-NEXT:    i32.eqz
; CHECK-NEXT:    br_if 0 # 0: down to label1
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    global.get g1
; CHECK-NEXT:    local.set 2
; CHECK-NEXT:    local.get 1
; CHECK-NEXT:    call externref_user
; CHECK-NEXT:    local.get 2
; CHECK-NEXT:    return
; CHECK-NEXT:  .LBB1_2: # %if.then.i
; CHECK-NEXT:    end_block # label1:
; CHECK-NEXT:    local.get 1
; CHECK-NEXT:    call externref_user
; CHECK-NEXT:    local.get 1
; CHECK-NEXT:    # fallthrough-return
entry:
  %lg1 = load %externref, ptr addrspace(1) @g1
  %lg2 = load %externref, ptr addrspace(1) @g2
  br i1 %bool, label %if.end.i, label %if.then.i

if.then.i:
  br label %if.end.i

if.end.i:
  %res = phi %externref [ %lg1, %entry ], [ %lg2, %if.then.i ]
  ; Add a dummy call to force local allocation.
  call void @externref_user(%externref %lg2)
  ret %externref %res
}

define %externref @local_copied_from_global_and_teed(i1 zeroext %bool) {
; CHECK-LABEL: local_copied_from_global_and_teed:
; CHECK:         .functype local_copied_from_global_and_teed (i32) -> (externref)
; CHECK-NEXT:    .local externref, externref
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    global.get g1
; CHECK-NEXT:    local.tee 1
; CHECK-NEXT:    local.set 2
; CHECK-NEXT:    block
; CHECK-NEXT:    local.get 0
; CHECK-NEXT:    br_if 0 # 0: down to label2
; CHECK-NEXT:  # %bb.1: # %if.then.i
; CHECK-NEXT:    global.get g2
; CHECK-NEXT:    local.set 2
; CHECK-NEXT:  .LBB2_2: # %if.end.i
; CHECK-NEXT:    end_block # label2:
; CHECK-NEXT:    local.get 1
; CHECK-NEXT:    call externref_user
; CHECK-NEXT:    local.get 2
; CHECK-NEXT:    # fallthrough-return
entry:
  %lg1 = load %externref, ptr addrspace(1) @g1
  %lg2 = load %externref, ptr addrspace(1) @g2
  br i1 %bool, label %if.end.i, label %if.then.i

if.then.i:
  br label %if.end.i

if.end.i:
  %res = phi %externref [ %lg1, %entry ], [ %lg2, %if.then.i ]
  ; Add a dummy call to force local allocation.
  call void @externref_user(%externref %lg1)
  ret %externref %res
}

%wasmref = type ptr addrspace(256)
declare %wasmref @llvm.wasm.ref.null(i32) nounwind

define %externref @local_set_by_ref_instruction(i1 zeroext %bool) {
; CHECK-LABEL: local_set_by_ref_instruction:
; CHECK:         .functype local_set_by_ref_instruction (i32) -> (externref)
; CHECK-NEXT:    .local externref
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    ref.null_extern
; CHECK-NEXT:    local.tee 1
; CHECK-NEXT:    call externref_user
; CHECK-NEXT:    local.get 1
; CHECK-NEXT:    # fallthrough-return
  %n1_untyped = call %wasmref @llvm.wasm.ref.null(i32 0)
  %n1 = addrspacecast %wasmref %n1_untyped to %externref
  call void @externref_user(%externref %n1)
  ret %externref %n1
}
